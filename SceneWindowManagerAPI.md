# Introduktion #

> Vi har tre objekttyper: fönster (BasicWindow och MainWindow, för närvarande. Det är ingen stor skillnad på dem), scener och en GameManager som håller reda på de båda. GameManagern är en singleton, så alla scener kommer åt den genom att skriva manager.scene\_manager, i stället för att initiera en ny instans.

# Fönster #

> Fönstren har i uppgift att rita scener till ett enda fönster på skärmen. De har ingen aning om vad de ritar, eller hur de gör det. Allt de gör är att kalla på en speciell funktion (som anges när de initieras), som ska finnas i alla scener som de ritar. Om en sådan funktion inte finns, händer inget värre än att fönstret blir tomt. Det finns två fönster just nu, ett för debuggning och ett för huvudvyn. Märk väl att, trots att huvudfönstret är av typen MainWindow och Debugfönstret av typen BasicWindow, skulle de båda kunna vara BasicWindow eller vad som helst. Fönsterinstanserna är skilda från klasserna (anledningen till att det ens finns två klasser är att  MainWindow stänger hela spelet när det stängs). Ritfunktionerna som jag pratade om är game\_draw, för huvudfönstret, och debug\_draw för debugfönstret.

# Scener #

> Scenerna har i uppgift att hålla reda på olika states i spelet, till exempel menyn, spelskärmen, grattis-du-vann-skärmen, o s v. Hela scenen körs i ett och samma objekt, så scenen håller alltså reda på all data som behövs, och har även en funktion för att uppdatera sig själv. Som jag sade tidigare har de också ritfunktioner. I ritfunktionen fungerar ritandet som när man skriver on\_draw-funktionen i pyglet.window.Window, med skillnaden att fönstret heter window i stället för self. Man kan även komma åt scenen genom argumentet scene (det här kan komma att ändras i framtiden, jag tyckte att en staticmethod var mer logisk. När man skriver scenen spelar det inte någon större roll, så länge du gör det lätt att byta ut "scene" mot "self", om jag skulle ändra mig.). Funktionen för att uppdatera scenen heter do\_logic, och den är en vanlig instansfunktion och funkar därmed med self. Anledningen till att logiken är åtskild från ritandet är att vi kan ha flera fönster som tittar på samma scen. Därmed är det STRIKT FÖRBJUDET att ändra på själva sceninstansen, annat än för att skapa temporära medlemmar i klassen, som bara används för att just rita. Det kanske är smart att döpa dessa med prefix, i så fall, till exempel self.game\_meat\_label. Och just det: Pilla inte på init för ritandets skull, av samma anledning. Uppdatering av sceninstansen sker i do\_logic-metoden, så att ändringarna kan uppmärksammas av både huvudfönstret och debugfönstret (jag är övertydlig; förlåt, men det är väldigt viktigt det här). Du kan se ett exempel i TestScene, där self.time uppdateras varje gång do\_logic kallas på, och läses av varje gång man ritar. En annan viktig detalj angående det här är att do\_logic kan komma att anropas oftare än renderingsfunktionerna, så att försöka uppdatera i de senare skulle inte funka ändå. (Om vi måste Fouriera oftare, ska vi inte vara tvugna att rita om skärmen oftare också. Se fönstren som en bild av hur spelet ser ut vid ett visst tillfälle, medan spelet självt i själva verket rullar på som om inget hade hänt och i en annan takt.) Just fan, do\_logic har som argument antalet sekunder som har passerat sedan funktionen kallades på senast. En till grej som jag inte har hunnit fixa än är input från tangentbordet och musen. De hanteras också i scenen. Jag fixar det snart.

# manager.game\_manager #
> Hur gör man då för att hålla reda på scener och fönster? Jo, det sker med vår lilla vän game\_managern. Den fungerar dels som en lista av fönster (add\_window(fönsterinstans, scenens\_funktion\_som\_sträng) för att lägga till ett fönster. Nu när jag skriver det här kommer jag på att det kan vara bra att kunna ta bort fönster också, eller att toggla deras synlighet. Jag fixar det snarast.). game\_manager fungerar också som en stack av scener, liknande den som cocos2d använder sig av i sin Director-klass. För att lägga till en scen ovanpå den nuvarande, kalla på game\_manager.push(scene). Scenen startar då så fort den nuvarande scenen har avslutat sin do\_logic-loop. pop gör det motsatta och tar bort en scen permanent (om man inte skriver scene = game\_manager.pop() och sedan game\_manager.push(scene) igen). Det finns ett antal andra trevliga funktioner för att hantera scenerna också.

# Bjas #

> Det blev lite rörigt. Jag sparar det här på wikin för framtida referens. Bajs.